name: Provision Staging Instance

on:
  workflow_dispatch:

jobs:
  provision:
    name: Create Staging EC2 Instance
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Import SSH key pair
        id: keypair
        run: |
          KEY_PAIR_NAME="handy-staging-key"

          # Check if key pair already exists
          EXISTING=$(aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" 2>/dev/null || true)
          if echo "$EXISTING" | grep -q "$KEY_PAIR_NAME"; then
            echo "Key pair '$KEY_PAIR_NAME' already exists"
          else
            echo "Importing key pair from EC2_SSH_PRIVATE_KEY secret..."
            # Extract public key from private key
            echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > /tmp/privkey.pem
            chmod 600 /tmp/privkey.pem
            ssh-keygen -y -f /tmp/privkey.pem > /tmp/pubkey.pub
            rm /tmp/privkey.pem

            aws ec2 import-key-pair \
              --key-name "$KEY_PAIR_NAME" \
              --public-key-material fileb:///tmp/pubkey.pub
            rm /tmp/pubkey.pub
            echo "Key pair imported successfully"
          fi

          echo "key_name=$KEY_PAIR_NAME" >> $GITHUB_OUTPUT

      - name: Discover infrastructure
        id: infra
        run: |
          echo "=== Getting default VPC ==="
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" \
            --query 'Vpcs[0].VpcId' --output text)
          echo "Default VPC: $VPC_ID"

          echo ""
          echo "=== Getting subnet with public IP auto-assign ==="
          SUBNET_ID=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=map-public-ip-on-launch,Values=true" \
            --query 'Subnets[0].SubnetId' --output text)

          if [ "$SUBNET_ID" = "None" ] || [ -z "$SUBNET_ID" ]; then
            echo "No subnet with auto-assign public IP, using first subnet"
            SUBNET_ID=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[0].SubnetId' --output text)
          fi
          echo "Subnet: $SUBNET_ID"

          echo ""
          echo "=== Setting up security group ==="
          SG_NAME="handy-staging-sg"
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=$SG_NAME" \
            --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")

          if [ "$SG_ID" = "None" ] || [ -z "$SG_ID" ]; then
            echo "Creating security group..."
            SG_ID=$(aws ec2 create-security-group \
              --group-name "$SG_NAME" \
              --description "Handy Chat Staging - SSH, HTTP, HTTPS" \
              --vpc-id "$VPC_ID" \
              --query 'GroupId' --output text)

            aws ec2 authorize-security-group-ingress --group-id "$SG_ID" \
              --ip-permissions \
              '[{"IpProtocol":"tcp","FromPort":22,"ToPort":22,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]},{"IpProtocol":"tcp","FromPort":80,"ToPort":80,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]},{"IpProtocol":"tcp","FromPort":443,"ToPort":443,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]}]'
            echo "Security group created with SSH/HTTP/HTTPS rules"
          else
            echo "Security group already exists: $SG_ID"
          fi
          echo "Security Group: $SG_ID"

          echo ""
          echo "=== Getting latest AL2023 ARM64 AMI ==="
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=al2023-ami-2023*-kernel-*-arm64" "Name=state,Values=available" \
            --query 'sort_by(Images, &CreationDate)[-1].ImageId' --output text)
          echo "AMI: $AMI_ID"

          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT

      - name: Ensure Elastic IP
        id: eip
        run: |
          # 기존 handy-staging EIP 탐색
          EIP_ALLOC=$(aws ec2 describe-addresses \
            --filters "Name=tag:Name,Values=handy-staging-eip" \
            --query 'Addresses[0].AllocationId' --output text)

          if [ "$EIP_ALLOC" = "None" ] || [ -z "$EIP_ALLOC" ]; then
            echo "Allocating new Elastic IP..."
            EIP_ALLOC=$(aws ec2 allocate-address \
              --tag-specifications 'ResourceType=elastic-ip,Tags=[{Key=Name,Value=handy-staging-eip}]' \
              --query 'AllocationId' --output text)
            echo "Allocated new EIP: $EIP_ALLOC"
          else
            echo "Found existing EIP: $EIP_ALLOC"
          fi

          EIP_IP=$(aws ec2 describe-addresses --allocation-ids $EIP_ALLOC \
            --query 'Addresses[0].PublicIp' --output text)

          echo "Elastic IP: $EIP_IP (Allocation: $EIP_ALLOC)"
          echo "eip_alloc=$EIP_ALLOC" >> $GITHUB_OUTPUT
          echo "eip_ip=$EIP_IP" >> $GITHUB_OUTPUT

      - name: Terminate old staging instances
        run: |
          echo "=== Terminating old staging instances ==="
          OLD_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=handy-chat-staging" "Name=instance-state-name,Values=running,stopped,stopping" \
            --query 'Reservations[].Instances[].InstanceId' --output text)
          if [ -n "$OLD_IDS" ] && [ "$OLD_IDS" != "None" ]; then
            echo "Terminating: $OLD_IDS"
            aws ec2 terminate-instances --instance-ids $OLD_IDS
            aws ec2 wait instance-terminated --instance-ids $OLD_IDS
            echo "Old instances terminated"
          else
            echo "No old instances to terminate"
          fi

      - name: Create staging spot instance
        id: staging
        run: |
          echo "Creating staging spot instance..."
          echo "  AMI: ${{ steps.infra.outputs.ami_id }}"
          echo "  Key: ${{ steps.keypair.outputs.key_name }}"
          echo "  SG:  ${{ steps.infra.outputs.sg_id }}"
          echo "  Subnet: ${{ steps.infra.outputs.subnet_id }}"
          echo "  EIP: ${{ steps.eip.outputs.eip_ip }} (${{ steps.eip.outputs.eip_alloc }})"

          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ${{ steps.infra.outputs.ami_id }} \
            --instance-type t4g.small \
            --key-name ${{ steps.keypair.outputs.key_name }} \
            --security-group-ids ${{ steps.infra.outputs.sg_id }} \
            --subnet-id ${{ steps.infra.outputs.subnet_id }} \
            --instance-market-options '{"MarketType":"spot","SpotOptions":{"SpotInstanceType":"persistent","InstanceInterruptionBehavior":"stop"}}' \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=handy-chat-staging}]' \
            --block-device-mappings '[{"DeviceName":"/dev/xvda","Ebs":{"VolumeSize":20,"VolumeType":"gp3"}}]' \
            --query 'Instances[0].InstanceId' --output text)

          echo "Instance ID: $INSTANCE_ID"
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID

          echo "Waiting for status checks..."
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID

          echo "Associating Elastic IP..."
          aws ec2 associate-address \
            --instance-id $INSTANCE_ID \
            --allocation-id ${{ steps.eip.outputs.eip_alloc }}

          echo "instance_ip=${{ steps.eip.outputs.eip_ip }}" >> $GITHUB_OUTPUT

      - name: Print staging instance info
        run: |
          echo "============================================"
          echo "  STAGING INSTANCE CREATED SUCCESSFULLY"
          echo "============================================"
          echo ""
          echo "  Instance ID:  ${{ steps.staging.outputs.instance_id }}"
          echo "  Elastic IP:   ${{ steps.staging.outputs.instance_ip }}"
          echo "  EIP Alloc ID: ${{ steps.eip.outputs.eip_alloc }}"
          echo "  Type:         Spot (persistent, stop on interrupt)"
          echo ""
          echo "  Next steps:"
          echo "  1. Add GitHub Secret: STAGING_EC2_HOST = ${{ steps.staging.outputs.instance_ip }}"
          echo "  2. Run setup-staging workflow to install dependencies"
          echo "  3. Run CD workflow to deploy"
          echo "============================================"

      - name: Setup staging server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.eip.outputs.eip_ip }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          port: 22
          command_timeout: 10m
          script_stop: true
          script: |
            echo "=== Installing Docker and Git ==="
            sudo dnf install -y docker git
            sudo systemctl enable docker
            sudo systemctl start docker
            sudo usermod -aG docker $USER
            echo "=== Fix containerd gRPC message size limit ==="
            sudo mkdir -p /etc/containerd
            printf 'version = 3\n\n[grpc]\n  max_recv_message_size = 268435456\n  max_send_message_size = 268435456\n\n[proxy_plugins]\n  [proxy_plugins.soci]\n    type = "snapshot"\n    address = "/run/soci-snapshotter-grpc/soci-snapshotter-grpc.sock"\n' | sudo tee /etc/containerd/config.toml
            sudo systemctl restart containerd || true
            sudo systemctl restart docker
            echo "=== Installing Docker Buildx ==="
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            BUILDX_VERSION=0.19.3
            sudo curl -SL "https://github.com/docker/buildx/releases/download/v${BUILDX_VERSION}/buildx-v${BUILDX_VERSION}.linux-arm64" \
              -o /usr/local/lib/docker/cli-plugins/docker-buildx
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-buildx
            echo "=== Installing Docker Compose ==="
            sudo curl -SL "https://github.com/docker/compose/releases/latest/download/docker-compose-linux-aarch64" \
              -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            echo "=== Verify installations ==="
            docker --version
            docker buildx version
            docker compose version
            git --version
            echo "=== Setup project directory ==="
            sudo mkdir -p /opt/chat-staging
            sudo chown ec2-user:ec2-user /opt/chat-staging
            echo "=== Setup complete ==="
